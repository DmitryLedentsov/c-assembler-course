Семинар 8.(Последний, наконец-то...)
man fork выдаёт следующее:
1) fork() - создаёт новый процесс и возвращает число: 0 - в дочернем процессе, и id процесса - в
родительском процессе или -1 если ошибка.При вызове fork() возникают два полностью идентичных процесса. Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

execve() выполняет программу, заданную параметром filename. Заменяет текущий образ процесса новым образом процесса(наследуя PID и прочее).
2) Запускаем программу, видим, что выдаётся id дочернего процесса:
    Shared memory at: 0x7f31e97d3000
    Child's pid is: 5732

    Делаем pstree|grep a.out (название программы может быть другим, это какое у меня после gcc main.c+делал в Konsole манжары):

            |         |             |-konsole-+-zsh---a.out---a.out

    Как видим, создалось 2 процесса - сама программа+дочерний.
    Удостовериться в этом можно сделав ps aux|grep a.out :
    potato_+    5731 99.5  0.0   2496   880 pts/1    R+   22:15   1:57 ./a.out
    potato_+    5732 99.5  0.0   2496   104 pts/1    R+   22:15   1:57 ./a.out
    potato_+    6561  0.0  0.0   6596  2512 pts/2    S+   22:17   0:00 grep a.out

    Если перейдём в файл maps в proc/PID/<id процесса>/ для обоих процессов, то увидим примерно такое:

55a19f42d000-55a19f42e000 r--p 00000000 103:06 4335206                   /home/potato_coder/Рабочий стол/MyProjects/seminar8/a.out
55a19f42e000-55a19f42f000 r-xp 00001000 103:06 4335206                   /home/potato_coder/Рабочий стол/MyProjects/seminar8/a.out
55a19f42f000-55a19f430000 r--p 00002000 103:06 4335206                   /home/potato_coder/Рабочий стол/MyProjects/seminar8/a.out
55a19f430000-55a19f431000 r--p 00002000 103:06 4335206                   /home/potato_coder/Рабочий стол/MyProjects/seminar8/a.out
55a19f431000-55a19f432000 rw-p 00003000 103:06 4335206                   /home/potato_coder/Рабочий стол/MyProjects/seminar8/a.out
55a1a117f000-55a1a11a0000 rw-p 00000000 00:00 0                          [heap]
7f31e95c1000-7f31e95c4000 rw-p 00000000 00:00 0
7f31e95c4000-7f31e95e6000 r--p 00000000 103:06 2369226                   /usr/lib/libc.so.6
7f31e95e6000-7f31e9741000 r-xp 00022000 103:06 2369226                   /usr/lib/libc.so.6
7f31e9741000-7f31e9798000 r--p 0017d000 103:06 2369226                   /usr/lib/libc.so.6
7f31e9798000-7f31e979c000 r--p 001d4000 103:06 2369226                   /usr/lib/libc.so.6
7f31e979c000-7f31e979e000 rw-p 001d8000 103:06 2369226                   /usr/lib/libc.so.6
7f31e979e000-7f31e97ab000 rw-p 00000000 00:00 0
7f31e97d3000-7f31e97d4000 rw-s 00000000 00:01 8747                       /dev/zero (deleted)
7f31e97d4000-7f31e97d6000 rw-p 00000000 00:00 0
7f31e97d6000-7f31e97d7000 r--p 00000000 103:06 2369217                   /usr/lib/ld-linux-x86-64.so.2
7f31e97d7000-7f31e97fd000 r-xp 00001000 103:06 2369217                   /usr/lib/ld-linux-x86-64.so.2
7f31e97fd000-7f31e9807000 r--p 00027000 103:06 2369217                   /usr/lib/ld-linux-x86-64.so.2
7f31e9807000-7f31e9809000 r--p 00031000 103:06 2369217                   /usr/lib/ld-linux-x86-64.so.2
7f31e9809000-7f31e980b000 rw-p 00033000 103:06 2369217                   /usr/lib/ld-linux-x86-64.so.2
7ffe252be000-7ffe252e0000 rw-p 00000000 00:00 0                          [stack]
7ffe253ee000-7ffe253f2000 r--p 00000000 00:00 0                          [vvar]
7ffe253f2000-7ffe253f4000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]

Если сравним оба файла, то найдём ту самую общую строку, место которой выдаётся программой:
7f31e97d3000-7f31e97d4000 rw-s 00000000 00:01 8747                       /dev/zero (deleted)

Задание 1.

Сделано, в файле task_1.c Если нужно пояснение - пиши.

Вопрос 3.

Судя по всему нет, не нужно, т.к. у нас всё равно в конце стоит waitpid(), который дождётся, пока
ребёнок не завершит своё выполнение(т.е. не пришлёт сообщение и не убьётся как процесс).

Задание 2.

В файле task_2.c


Хочу уточнить кое-что - семафор может являться подобием мьютекса при 1, но всё отличие в том, что мьютекс имеет эксклюзивного владельца, который и должен его освобождать.
Вопрос 4.(про файл с мьютексом и без)

Операция инкремента у нас не атомарная(увеличение на 1, потом сохранение ещё, несколько операций короче)
Поэтому без мьютексов происходят случаи, когда один поток провёл операцию, но не успел записать это,
а второй в это время тоже записывает значение, поэтому когда число циклов достигает 2 миллионов, n меньше этого числа.

Задание 3.(Синхронизировать с помощью семафоров.)

Сделано, в файле task_3.c

Вопросик(про thread'ы): просто погуглите состояние гонки, это оно и есть. Да и в общем-то я описывал в предыдущем вопросе, что примерно происходит.


Задание 4.

Сделано, в task_4.c
